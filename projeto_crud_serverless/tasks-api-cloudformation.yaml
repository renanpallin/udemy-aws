AWSTemplateFormatVersion: "2010-09-09"
Description: |
  Tasks API - Infraestrutura Serverless Completa
  Deploy multi-regi√£o com DynamoDB, Lambda e API Gateway
  Curso AWS Developer Associate (DVA-C02) - Renan Pallin

Parameters:
  Environment:
    Type: String
    Default: prod
    AllowedValues:
      - dev
      - prod
    Description: Ambiente de deploy (dev ou prod)

Resources:
  # ==========================================
  # DYNAMODB TABLE
  # ==========================================
  TasksTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: Tasks
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: user_id
          AttributeType: S
        - AttributeName: created_at
          AttributeType: S
      KeySchema:
        - AttributeName: user_id
          KeyType: HASH
        - AttributeName: created_at
          KeyType: RANGE
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Project
          Value: TasksAPI

  # ==========================================
  # IAM ROLE PARA LAMBDA
  # ==========================================
  TasksLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "tasks-lambda-role-${Environment}"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: "sts:AssumeRole"
      ManagedPolicyArns:
        - "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
        - "arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess"
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "dynamodb:PutItem"
                  - "dynamodb:GetItem"
                  - "dynamodb:Query"
                  - "dynamodb:Scan"
                  - "dynamodb:DeleteItem"
                  - "dynamodb:UpdateItem"
                Resource: !GetAtt TasksTable.Arn

  # ==========================================
  # LAMBDA FUNCTION
  # ==========================================
  TasksLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "tasks-api-${Environment}"
      Runtime: python3.13
      Handler: index.lambda_handler
      Timeout: 30
      MemorySize: 256
      Role: !GetAtt TasksLambdaRole.Arn
      TracingConfig:
        Mode: Active
      Environment:
        Variables:
          TABLE_NAME: !Ref TasksTable
          ENVIRONMENT: !Ref Environment
      Code:
        ZipFile: |
          import json
          import boto3
          import uuid
          from datetime import datetime, timezone, timedelta
          from boto3.dynamodb.conditions import Key, Attr

          # Configura√ß√£o DynamoDB
          dynamodb = boto3.resource('dynamodb')
          table = dynamodb.Table('Tasks')

          def lambda_handler(event, context):
              """
              üìù Tasks CRUD API
              Estrutura da tabela:
              - Partition Key: user_id (ex: "user001")
              - Sort Key: created_at (timestamp ISO)
              - Atributos: uuid (UUID), description, done
              """

              print(f"üìù Evento recebido: {json.dumps(event)}")

              method = event['httpMethod']
              path_params = event.get('pathParameters') or {}

              try:
                  if method == 'POST':
                      return create_task(event)
                  elif method == 'GET':
                      if path_params.get('uuid'):
                          return get_task_by_uuid(event)
                      else:
                          return list_tasks(event)
                  elif method == 'PUT':
                      return update_task(event)
                  elif method == 'DELETE':
                      return delete_task(event)
                  elif method == 'OPTIONS':
                      return options_response()
                  else:
                      return error_response(405, f'M√©todo {method} n√£o permitido')

              except Exception as e:
                  print(f"‚ùå Erro n√£o tratado: {str(e)}")
                  return error_response(500, f'Erro interno: {str(e)}')

          def create_task(event):
              """
              ‚ûï Criar nova task
              POST /tasks
              """
              print("‚ûï Criando nova task...")

              try:
                  body = json.loads(event['body'])
              except:
                  return error_response(400, 'JSON inv√°lido no body da requisi√ß√£o')

              # Queremos sempre um description nas nossas tasks
              if 'description' not in body or not body['description'].strip():
                  return error_response(400, 'Campo "description" √© obrigat√≥rio')

              # Gerar timestamp para Sort Key e UUID √∫nico
              created_at = datetime.now(timezone.utc).isoformat()
              task_id = str(uuid.uuid4())

              # Estrutura profissional: user_id (PK) + created_at (SK)
              item = {
                  'user_id': 'user001',                # Partition Key (mock)
                  'created_at': created_at,            # Sort Key (timestamp)
                  'uuid': task_id,                     # UUID √∫nico para refer√™ncia
                  'description': body['description'].strip(),
                  'done': bool(body.get('done', False))
              }

              try:
                  table.put_item(Item=item)
                  print(f"‚úÖ Task criada: {item['description']} (ID: {task_id})")

                  return success_response(201, {
                      'message': 'üìù Task criada com sucesso!',
                      'task': format_task_response(item)
                  })

              except Exception as e:
                  print(f"‚ùå Erro ao salvar no DynamoDB: {str(e)}")
                  return error_response(500, f'Erro ao salvar task: {str(e)}')

          def list_tasks(event):
              """
              üìã Listar tasks do usu√°rio com ordena√ß√£o nativa
              GET /tasks
              """
              print("üìã Listando tasks do user001...")

              try:
                  # Busca todas as tasks do usu√°rio
                  response = table.query(
                      KeyConditionExpression=Key('user_id').eq('user001'),
                      ScanIndexForward=False  # Ordem decrescente (mais recente primeiro)
                  )

                  items = response['Items']

                  print(f"‚úÖ Encontradas {len(items)} tasks (ordenadas nativamente)")

                  return success_response(200, {
                      'tasks': [format_task_response(item) for item in items],
                      'total': len(items)
                  })

              except Exception as e:
                  print(f"‚ùå Erro ao listar tasks: {str(e)}")
                  return error_response(500, f'Erro ao listar tasks: {str(e)}')

          def get_task_by_uuid(event):
              """
              üîç Buscar task espec√≠fica por UUID
              GET /tasks/{uuid}
              """
              task_id = event['pathParameters']['uuid']
              print(f"üîç Buscando task espec√≠fica: {task_id}")

              # Buscar task pelo UUID
              task = find_task_by_id(task_id)

              if not task:
                  print(f"‚ùå Task n√£o encontrada: {task_id}")
                  return error_response(404, f'Task "{task_id}" n√£o encontrada')

              print(f"‚úÖ Task encontrada: {task['description']}")

              return success_response(200, {
                  'task': format_task_response(task)
              })

          def update_task(event):
              """
              ‚úèÔ∏è Atualizar task existente
              PUT /tasks/{uuid}
              """
              task_id = event['pathParameters']['uuid']
              print(f"‚úèÔ∏è Atualizando task: {task_id}")

              try:
                  body = json.loads(event['body'])
              except:
                  return error_response(400, 'JSON inv√°lido no body da requisi√ß√£o')

              # Buscar task atual pelo UUID
              current_item = find_task_by_id(task_id)
              if not current_item:
                  return error_response(404, f'Task "{task_id}" n√£o encontrada')

              # Atualizar campos fornecidos
              if 'description' in body and body['description'].strip():
                  current_item['description'] = body['description'].strip()

              if 'done' in body:
                  current_item['done'] = bool(body['done'])

              try:
                  table.put_item(Item=current_item)

                  print(f"‚úÖ Task atualizada: {current_item['description']}")

                  return success_response(200, {
                      'message': '‚úèÔ∏è Task atualizada com sucesso!',
                      'task': format_task_response(current_item)
                  })

              except Exception as e:
                  print(f"‚ùå Erro ao atualizar task: {str(e)}")
                  return error_response(500, f'Erro ao atualizar task: {str(e)}')

          def delete_task(event):
              """
              üóëÔ∏è Deletar task
              DELETE /tasks/{uuid}
              """
              task_id = event['pathParameters']['uuid']
              print(f"üóëÔ∏è Deletando task: {task_id}")

              # Buscar task para pegar as chaves prim√°rias
              current_item = find_task_by_id(task_id)
              if not current_item:
                  return error_response(404, f'Task "{task_id}" n√£o encontrada')

              task_description = current_item['description']

              try:
                  # Deletar usando as chaves prim√°rias (user_id + created_at)
                  table.delete_item(
                      Key={
                          'user_id': current_item['user_id'],
                          'created_at': current_item['created_at']
                      }
                  )

                  print(f"‚úÖ Task deletada: {task_description}")

                  return success_response(200, {
                      'message': f'üóëÔ∏è Task "{task_description}" removida com sucesso!',
                      'deleted_uuid': task_id
                  })

              except Exception as e:
                  print(f"‚ùå Erro ao deletar task: {str(e)}")
                  return error_response(500, f'Erro ao deletar task: {str(e)}')

          def find_task_by_id(task_id):
              """
              üîç Buscar task pelo UUID
              """
              try:
                  response = table.query(
                      KeyConditionExpression=Key('user_id').eq('user001'),
                      FilterExpression=Attr('uuid').eq(task_id)
                  )

                  return response['Items'][0] if response['Items'] else None

              except Exception as e:
                  print(f"‚ùå Erro ao buscar task: {str(e)}")
                  return None

          def format_task_response(item):
              """
              üé® Formatar resposta para o cliente
              Converte UTC para hor√°rio brasileiro apenas na apresenta√ß√£o
              """
              # Converter UTC para hor√°rio brasileiro (UTC-3)
              utc_time = datetime.fromisoformat(item['created_at'].replace('Z', '+00:00'))
              brazil_tz = timezone(timedelta(hours=-3))
              brazil_time = utc_time.astimezone(brazil_tz)

              return {
                  'uuid': item['uuid'],
                  'description': item['description'],
                  'done': item['done'],
                  'created_at': brazil_time.strftime('%d/%m/%Y %H:%M:%S')  # Formato brasileiro leg√≠vel
              }

          def success_response(status_code, data):
              """
              ‚úÖ Resposta de sucesso padronizada
              """
              return {
                  'statusCode': status_code,
                  'headers': {
                      'Access-Control-Allow-Origin': '*',
                      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
                      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
                      'Content-Type': 'application/json'
                  },
                  'body': json.dumps(data, default=str)
              }

          def error_response(status_code, message):
              """
              ‚ùå Resposta de erro padronizada
              """
              return {
                  'statusCode': status_code,
                  'headers': {
                      'Access-Control-Allow-Origin': '*',
                      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
                      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
                      'Content-Type': 'application/json'
                  },
                  'body': json.dumps({
                      'error': message,
                      'timestamp': datetime.now(timezone.utc).isoformat()
                  })
              }

          def options_response():
              """
              üîß Resposta para requisi√ß√µes OPTIONS (CORS preflight)
              """
              return {
                  'statusCode': 200,
                  'headers': {
                      'Access-Control-Allow-Origin': '*',
                      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
                      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
                      'Access-Control-Max-Age': '86400'
                  },
                  'body': ''
              }

  # ==========================================
  # API GATEWAY - REST API
  # ==========================================
  TasksApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub "tasks-api-${Environment}"
      Description: Tasks CRUD API - Serverless
      EndpointConfiguration:
        Types:
          - REGIONAL

  # Resource: /tasks
  TasksResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref TasksApi
      ParentId: !GetAtt TasksApi.RootResourceId
      PathPart: tasks

  # Resource: /tasks/{uuid}
  TaskUuidResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref TasksApi
      ParentId: !Ref TasksResource
      PathPart: "{uuid}"

  # ==========================================
  # PERMISS√ÉO LAMBDA PARA API GATEWAY
  # ==========================================
  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref TasksLambda
      Action: "lambda:InvokeFunction"
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${TasksApi}/*/*"

  # ==========================================
  # M√âTODOS: /tasks
  # ==========================================

  # POST /tasks
  TasksPostMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref TasksApi
      ResourceId: !Ref TasksResource
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TasksLambda.Arn}/invocations"

  # GET /tasks
  TasksGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref TasksApi
      ResourceId: !Ref TasksResource
      HttpMethod: GET
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TasksLambda.Arn}/invocations"

  # OPTIONS /tasks (CORS)
  TasksOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref TasksApi
      ResourceId: !Ref TasksResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TasksLambda.Arn}/invocations"

  # ==========================================
  # M√âTODOS: /tasks/{uuid}
  # ==========================================

  # GET /tasks/{uuid}
  TaskUuidGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref TasksApi
      ResourceId: !Ref TaskUuidResource
      HttpMethod: GET
      AuthorizationType: NONE
      RequestParameters:
        method.request.path.uuid: true
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TasksLambda.Arn}/invocations"

  # PUT /tasks/{uuid}
  TaskUuidPutMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref TasksApi
      ResourceId: !Ref TaskUuidResource
      HttpMethod: PUT
      AuthorizationType: NONE
      RequestParameters:
        method.request.path.uuid: true
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TasksLambda.Arn}/invocations"

  # DELETE /tasks/{uuid}
  TaskUuidDeleteMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref TasksApi
      ResourceId: !Ref TaskUuidResource
      HttpMethod: DELETE
      AuthorizationType: NONE
      RequestParameters:
        method.request.path.uuid: true
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TasksLambda.Arn}/invocations"

  # OPTIONS /tasks/{uuid} (CORS)
  TaskUuidOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref TasksApi
      ResourceId: !Ref TaskUuidResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${TasksLambda.Arn}/invocations"

  # ==========================================
  # DEPLOYMENT
  # ==========================================
  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - TasksPostMethod
      - TasksGetMethod
      - TasksOptionsMethod
      - TaskUuidGetMethod
      - TaskUuidPutMethod
      - TaskUuidDeleteMethod
      - TaskUuidOptionsMethod
    Properties:
      RestApiId: !Ref TasksApi
      StageName: !Ref Environment

# ==========================================
# OUTPUTS
# ==========================================
Outputs:
  ApiUrl:
    Description: "URL da Tasks API"
    Value: !Sub "https://${TasksApi}.execute-api.${AWS::Region}.amazonaws.com/${Environment}"
    Export:
      Name: !Sub "${AWS::StackName}-ApiUrl"

  TableName:
    Description: "Nome da tabela DynamoDB"
    Value: !Ref TasksTable
    Export:
      Name: !Sub "${AWS::StackName}-TableName"

  LambdaFunctionArn:
    Description: "ARN da fun√ß√£o Lambda"
    Value: !GetAtt TasksLambda.Arn
    Export:
      Name: !Sub "${AWS::StackName}-LambdaArn"

  Region:
    Description: "Regi√£o do deploy"
    Value: !Ref "AWS::Region"
